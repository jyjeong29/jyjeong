//7월 1일자 버전
//변수 통합 이전 버전

#include <stdio.h> //standard input output
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/poll.h>
#include <termios.h> // B115200, CS8 등 상수 정의
#include <fcntl.h> // O_RDWR , O_NOCTTY 등의 상수 정의
#include <termio.h>
#include <termios.h>
#include <curses.h>
#include <assert.h>
#include <term.h>


static struct termios initial_settings, new_settings;
static int peek_character = -1;

void init_keyboard();// keyboard initialization
void close_keyboard();// stop using keyboard
int kbhit();// start to use keyboard 
int readch();// read data from keyboard input 


int main( void)
{
//###########################// send data from linux to teraterm

        //keyboard 입력 인식
        int ch = 0;
        init_keyboard();


	int fd_send, fd;

	//fd_send=open("/dev/ttyUSB0", O_RDWR | O_NOCTTY );  // 컨트롤 c 로 취소안되게 하기 | O_NOCTTY
	// when key 'q' is in, program is over 
	fd_send=open("/dev/ttyUSB0", O_RDWR ); //device 열기

	assert(fd_send != -1);

	struct termios newtio;//serial port setting하기
	
	// newtio <-- serial port setting.
	//memset(&newtio, 0, sizeof(struct termios));
	//newtio.c_cflag = B9600 | CS8 | CLOCAL | CREAD;//속도
	newtio.c_cflag = B115200 | CS8 | CLOCAL | CREAD;//속도
	newtio.c_iflag = IGNPAR | ICRNL;
	newtio.c_oflag = 0;
	newtio.c_lflag = ~(ICANON | ECHO | ECHOE | ISIG);


	tcflush(fd_send, TCIFLUSH);
	tcsetattr(fd_send, TCSANOW, &newtio);


	//send text from linux to teraterm
	const char *str = "serial program. sending text from linux to window \r\n";
	write(fd_send, str, strlen(str)+1);




//##########################//get data from teraterm configure
        //int    fd;
        //int    ndx;
        int    cnt;
        char   buf[1024]="\0";//
        struct pollfd     poll_events;      // 체크할 event 정보를 갖는 struct
        int    poll_state;

        // 시리얼 포트를 open
        fd = open( "/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NONBLOCK );

        //error 설정
        if ( 0 > fd)
        {
                printf("open error\n");
                return -1;
        }

        // 시리얼 포트 통신 환경 설정

        //struct termios    newtio;//re used
        memset( &newtio, 0, sizeof(newtio) );
        //newtio.c_cflag       = B9600 | CS8 | CLOCAL | CREAD;
        newtio.c_cflag       = B115200 | CS8 | CLOCAL | CREAD;
        newtio.c_oflag       = 0;
        newtio.c_lflag       = 0;
        newtio.c_cc[VTIME]   = 0;
        newtio.c_cc[VMIN]    = 1;

        tcflush  (fd, TCIFLUSH );
        tcsetattr(fd, TCSANOW, &newtio );
        fcntl(fd, F_SETFL, FNDELAY);

        // poll 사용을 위한 준비
        poll_events.fd        = fd;
        poll_events.events    = POLLIN | POLLERR; //수신된 자료가 있는지, 에러가
        poll_events.revents   = 0;


	//send data from linux to teraterm
        //write(fd, "forum.falinux.com", 17);
        write(fd,"serial communication start",26);
        write(fd,"\r",1);


	// start polling 
        while (ch != 'q')
        {

		//send data from linux to teraterm
                //printf("looping\n");
                //sleep(1);

		//지금 이게 느린건데...
                if(kbhit())
                {
                        ch = readch();
                        printf("send : %c\n\r",ch);
                        write(fd_send, &ch ,3);
                }
		//send data end

//#############################################################

		//get data from teraterm to linux
                poll_state = poll( // poll()을 호출하여 event 발생 여부 확인     
                                (struct pollfd*)&poll_events, // event 등록 변수
                                1, // 체크할 pollfd 개수
                                1000   // time out 시간
                                );

                if ( 0 < poll_state) // 발생한 event 가 있음
                {
                        if(poll_events.revents & POLLIN) // event 가 자료 수신?
                        {
                                cnt = read(fd, buf, 1024); //terminal에서 입력한
                                write( fd, buf, cnt);
                                printf( " get : %d %s\r", cnt, buf);
                        }

                                // 여긴 발생할 일 별로 없음
                                if( poll_events.revents & POLLERR)      // event 가 에러?
                        {
                                printf( "통신 라인에 에러가 발생, 프로그램 종료");
                                break;
                        }
                }
        }

	//stop initialization
	close_keyboard();
	exit(0);
	close(fd_send);
        close(fd);
        return 0;
}

//keyboard 설정 초기화
void init_keyboard()
{
    tcgetattr(0,&initial_settings);
    new_settings = initial_settings;
    new_settings.c_lflag &= ~ICANON;
    new_settings.c_lflag &= ~ECHO;
    new_settings.c_lflag &= ~ISIG;
    new_settings.c_cc[VMIN] = 1;
    new_settings.c_cc[VTIME] = 0;
    tcsetattr(0, TCSANOW, &new_settings);
}

void close_keyboard()
{
    tcsetattr(0, TCSANOW, &initial_settings);
}

int kbhit()
{
    char ch;
    int nread;

    if(peek_character != -1)
        return 1;
    new_settings.c_cc[VMIN]=0;
    tcsetattr(0, TCSANOW, &new_settings);
    nread = read(0,&ch,1);
    new_settings.c_cc[VMIN]=1;
    tcsetattr(0, TCSANOW, &new_settings);

    if(nread == 1) {
        peek_character = ch;
        return 1;
    }
    return 0;
}

int readch()
{
    char ch;

    if(peek_character != -1) {
        ch = peek_character;
        peek_character = -1;
        return ch;
    }
    read(0,&ch,1);
    return ch;
}





